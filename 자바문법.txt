public static void main(String[ ] args)
String[ ] args : args는 String타입의 배열주소를 가지는 변수
Run Configurations 의 Arguments 탭

자바 소스파일 기본구조
package 패키지명;			//패키지 선언
import 패키지명[.하위패키지명].클래스명;
				//클래스 임포트
제어자 class 클래스명 {		//클래스 선언
  제어자 데이터타입 필드명;		//필드 선언
  생성자선언
  제어자 반환타입 메서드명(매개변수) {	//메서드 선언
    실행문;
}

변수, 메서드	: 소문자 시작
클래스		: 대문자 시작

접근제한자
private	: 외부접근 막음
default	: 같은패키지로 접근 제한
protected	: 다른패키지는 상속되야 접근
public	: 외부공개
접근제한자 class 클래스명 {
  접근제한자 필드선언;
  접근제한자 메서드선언
}

제어자
final	: 변숫값 수정X 메서드 오버라이딩X 클래스 상속X
static	: 모든 인스턴스가 공유
abstract	: 추상
추상 메서드 포함하는 클래스 역시 추상 선언
상속받은 클래스는 오버라이딩하여 메서드 본문 구현

인터페이스 선언
제어자 interface 인터페이스명 {
  접근제한자 제어자 변수선언;
  접근제한자 제어자 메서드선언( );
}
필드 선언부에 public, static, final 제어자 자동 추가
메서드 선언부에 public, abstract 제어자 자동 추가

default메서드 선언
public default 리턴타입 메서드명(매개변수) {
  실행문;
}
자바8부터 default, static메서드 선언하여 본문 가질수 있음

인터페이스 상속
제어자 class 클래스명 extends 부모클래스명 \
			\ implements 인터페이스명 {
}
인터페이스를 (,)를 구분자로 다중상속 가능

클래스 선언
class 클래스명 {
  필드 선언;
  생성자 선언
  메서드 선언
  클래스 선언	// 내부 클래스(특정 클래스에서만 사용)
}

클래스 상속
접근제한자 class 클래스명 extends 부모클래스명 {
}

클래스 생성
new 클래스명( );

필드선언
데이터타입 변수이름;
<or>
데이터타입 변수이름 = 값;

클래스 필드 사용 (static 선언)
클래스명.필드명;

인스턴스 필드 사용 (static 선언x)
인스턴스 생성해 참조변수 통해 사용
클래스명 참조변수 = new 클래스명( );
참조변수.필드명;

인스턴스 맴버 클래스
외부클래스참조변수.new 내부클래스명( );
다른클래스 맴버X
자신이 속한 외부클래스 인스턴스로 접근

정적 맴버 클래스
new 외부클래스명.내부클래스명( );

로컬 클래스
메서드 내에 선언하는 내부클래스

익명 클래스
인터페이스명 변수명 = new 인터페이스명( ) {
  인터페이스의 메서드 오버라이딩
}

열거형 클래스
enum 클래스명 {
  열거상수1, 열거상수2, .., 열거상수
}
public, static, final 자동 선언

메서드선언
데이터타입 메서드이름(매개변수1, 매개변수2){
  실행문
}
돌려주는 값이 없을떈 데이터타입 void
반환값: 실행되는 메서드가 호출한 곳으로 전달
인자값: 호출하는 곳에서 메서드로 전달
매개변수: 인자값 받아서 저장하는 변수

메서드 호출
메서드명( );

메서드 오버로딩
같은 이름의 메서드를 매개변수 구성만 다르게 해서 선언

메서드 오버라이딩
정의된 메서드를 재정의해 사용
상속한 메서드의 본문만 변경
선언부 변경 안됨
접근 제한자는 부모 이상 가능

부모메서드 호출
super.메서드명(인자);
자식클래스 모든 생성자에 자동 추가

가변 길이 인자 선언
메서드이름(데이터타입... 변수이름){ }

게터	getName( )
private 선언된 필드값을 반환 하는 메서드
세터	setName(인자)
private 선언된 필드에 데이터 설정 하는 메서드

참조변수 선언
클래스명 참조변수명 = new 클래스명( );

참조변수 사용
참조변수명.필드명
참조변수명.메서드명( )

생성자
클래스에 선언하는 메서드
인스턴스 생성시 자동 호출
반환값 없음
클래스와 이름같아 대문자 시작
개발자가 선언하지 않으면 컴파일러가 자동으로 추가
제어자 (리턴타입누락) 클래스명(매개변수생략가능){
  실행문;
}

생성자 실행
new 생성자명( );

생성자 호출
생성자내에서만 사용, 가장 첫 번째 줄
this( )

변수표기
카멜 depositAmount
파스칼 DepositAmount
스네이크 deposit_amount

주석 //한줄  /* 여러줄 */
@어노테이션 /** javadoc */

데이터종류
논리 boolean isMarried=true;
문자 char gender = "F"
정수 int age = 23;
실수 double PI =3.14;
참조 String name = "Amy";

정수타입
byte short int long
실수타입
float double
타입 캐스팅
(데이터타입) 변수명 또는 값;

! not 	& and	| or	^ xor	~ 비트부정

삼항 연산자
변수 = <비교>조건 ? <true>명령1 : <false>명령2

if 문
if(조건식) {조건식 참일때 실행문;
} 

if ~ else 문
if(조건식) {
  조건식 참일때 실행문;
  } else {
  조건식 거짓일떄 실행문;
}

if ~ elseif 문
if(조건식1) {
  조건식1 참일때 실행문;
  } else if(조건식2) {
  조건식 1 거짓, 조건식2 참일때 실행문; }
  } else { 조건식 모두 거짓일때 실행문;
}

ㄴswitch(조건식) {
case 값1 : 실행문1;
case 값1 : 실행문2;
case 값1 : 실행문3;
default : 실행문4;
}
break : 실행을 멈추고 블록 빠져나오기
default : 조건에 맞는 값이 없을 때 실행

반복문
for 문
for(제어 변수 선언 및 초기화 ; 조건식 ; 증감식){
  실행문;
}

확장for문
for(변수선언 : 배열변수명){
  실행문;
}

while 문
제어변수 선언 및 초기화;
while(조건식) {
  실행문;
  증감식;
}

do ~ while 문
제어변수 선언 및 초기화;
do {
  실행문;
  증감식;
} while(조건식);

break : 실행을 멈추고 반복문 탈출하기
continue : 그다음 조건으로 계속 실행하기

배열 생성
new 데이터타입[요소수];

배열 변수 선언
데이터타입[ ] 변수명;
<or>
데이터타입 변수명[ ]

배열에 접근
배열변수명[인덱스]

배열 길이 구하기
배열변수명.length

2차원 배열 선언
new 데이터타입 [행의수] [열의수]

2차원 배열 참조변수 선언
데이터타입[ ] [ ] 변수명;
<or>
데이터타입 변수명 [ ] [ ]

2차원 배열에 접근
배열변수명[행인덱스][열인덱스]

배열변수명.length	: 2차원 배열에서 행의 길이
배열변수명[행인덱스].length	: 2차원 배열에서 열의 길이

메서드 실행 멈추고 값 반환
return  값;

instanceof 연산자
if(참조변수 instanceof 객체타입) {실행문; }
참조변수가 참조하는 인스턴스의 타입 검사

타입변경
(데이터타입)참조변수;

타입변경 후 실행
((데이터타입)참조변수).변수;
((데이터타입)참조변수).메서드( );

예외처리
try{
  실행문;
} catch (변수선언) {  
  예외처리;
} finally { 자원해제 }

try(클래스명 변수명 = new 클래스명()){
  실행문
} catch (Exception e) {
  예외 처리
}

예외 던지기
메서드 선언부에 throws 다음에 메서드 내에서 처리할 Exception 객체를 선언

예외상황 강제 발생
throw new 예외객체명( );

파일 입출력
FileInputStream(File file)	FileOutputStream(File file)

인터페이스 구현
1. Implements 키워드로 클래스 선언
class MyClass1 implements MyInterface {
  @Override
  public void print{ } {
    System.out.println("MyClass1");
    }
  }
실행은 인터페이스 구현한 클래스의 인스턴스 생성후 참조변수 이용해 호출

2. 익명 클래스 사용
인터페이스명 변수명 =new 인터페이스명( ) {
  메서드오버라이딩
};
실행은 참조변수 이용

3. 선언, 생성, 호출을 한번에 처리
(new 인터페이스명( ) {
  메서드오버라이딩
}) . 메서드명( );

람다식	일반 인터페이스 구현과 동일한 기능, 하나의 메서드만 선언
(변수명1, ...,변수명n ) -> 명령문;
( ) -> {
  명령문1;
  명령문n;
  return 값;
};
예외처리는 함수형 인터페이스의 추상 메서드 선언에서 throws 키워드 지정

제네릭
컬렉션 객체를 생성할 떄 저장되는 데이터의 타입을 미리 지정
잘못된 저장 예방과 추출할떄 타입 변경 생략
<타입매개변수>	: Collection에 저장
클래스<데이터타입>변수 = new 클래스<데이터타입>( );

class 클래스명<타입매개변수>{	제네릭 클래스 선언
}

new 클래스명<타입인자>{ };		제네릭 클래스 생성

클래스명<타입인자>		제네릭 클래스 참조

<? extends 슈퍼클래스>		상위제한

<? extends 서브클래스>		하위제한

제너릭 메서드에 타입 매개변수 선언
<타입매개변수목록>리턴타입 메서드명(매개변수목록) { ... }

제너릭 인터페이스에 타입 인자 전달
인터페이스명<타입인자> 변수명 = ( ) -> 명령문

어노테이션 선언
@interface 어노테이션명 {
  데이터타입 변수명( );
}

어노테이션 사용
@어노테이션명(변수명 = 값, 변수명 = 갑사)

인터페이스 객체 생성
클래스명::메서드명
참조변수명::메서드명

제네릭 메서드 참조
클래스명::<타입>메서드명

생성자 참조로 인터페이스 객체 생성
클래스명:: new
